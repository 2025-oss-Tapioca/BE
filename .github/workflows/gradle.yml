# .github/workflows/deploy.yml
name: "🚀 Spring Boot Docker CI/CD (no compose)"

on:
  push:
    branches: ["main", "Dev"]

concurrency:
  group: ci-${{ github.ref }}
  cancel-in-progress: true

jobs:
  build-and-deploy:
    runs-on: ubuntu-latest
    timeout-minutes: 45

    env:
      IMAGE_NAME: ${{ secrets.DOCKER_USERNAME }}/docker-test
      APP_PORT: "8080" # 컨테이너 내부/외부 포트 (Spring 기본 8080)

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up JDK 17
        uses: actions/setup-java@v4
        with:
          java-version: "17"
          distribution: "temurin"
          cache: "gradle"

      # 시크릿에 APPLICATION_YML(원문) 넣은 경우에만 파일 생성
      - name: Create application.yml from Secrets (optional)
        env:
          APPLICATION_YML: ${{ secrets.APPLICATION_YML }}
        run: |
          mkdir -p ./src/main/resources
          if [ -n "${APPLICATION_YML:-}" ]; then
            printf '%s' "$APPLICATION_YML" > ./src/main/resources/application.yml
            echo "application.yml created from secret."
          else
            echo "APPLICATION_YML is empty. Skipping."
          fi

      - name: Grant execute permission for gradlew
        run: chmod +x ./gradlew

      - name: Build with Gradle (skip tests)
        run: ./gradlew clean build -x test

      - name: Log in to Docker Hub
        uses: docker/login-action@v3
        with:
          username: ${{ secrets.DOCKER_USERNAME }}
          password: ${{ secrets.DOCKER_PASSWORD }}

      - name: Build and push Docker image
        run: |
          set -euo pipefail
          IMAGE_SHA="${IMAGE_NAME}:${{ github.sha }}"
          IMAGE_BRANCH="${IMAGE_NAME}:${{ github.ref_name }}"
          echo "Building $IMAGE_SHA and $IMAGE_BRANCH"
          docker build -t "$IMAGE_SHA" -t "$IMAGE_BRANCH" .
          docker push "$IMAGE_SHA"
          docker push "$IMAGE_BRANCH"
          echo "image_sha=$IMAGE_SHA" >> $GITHUB_OUTPUT
          echo "image_branch=$IMAGE_BRANCH" >> $GITHUB_OUTPUT

      - name: Remote deploy to EC2 (no compose)
        uses: appleboy/ssh-action@v1.0.3
        with:
          host: ${{ secrets.HOST }}
          port: ${{ secrets.PORT }}
          username: ubuntu
          key: ${{ secrets.PRIVATE_KEY }}
          script: |
            set -euo pipefail

            IMAGE="${{ secrets.DOCKER_USERNAME }}/docker-test:${{ github.sha }}"
            CONTAINER_NAME="web"
            APP_PORT="${{ env.APP_PORT }}"

            echo "[INFO] Using image: $IMAGE"

            # 0) 기본 패키지 업데이트 (조용히)
            sudo apt-get update -y -qq || true

            # 1) docker 설치 여부 확인 & 설치 (Ubuntu)
            if ! command -v docker >/dev/null 2>&1; then
              echo "[INFO] Docker not found. Installing..."
              sudo apt-get install -y -qq ca-certificates curl gnupg lsb-release
              sudo install -m 0755 -d /etc/apt/keyrings
              curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo gpg --dearmor -o /etc/apt/keyrings/docker.gpg
              echo \
                "deb [arch=$(dpkg --print-architecture) signed-by=/etc/apt/keyrings/docker.gpg] https://download.docker.com/linux/ubuntu \
                $(. /etc/os-release && echo "$VERSION_CODENAME") stable" | \
                sudo tee /etc/apt/sources.list.d/docker.list > /dev/null
              sudo apt-get update -y -qq
              sudo apt-get install -y -qq docker-ce docker-ce-cli containerd.io docker-buildx-plugin docker-compose-plugin
            fi

            # 2) docker 데몬 기동/복구
            echo "[INFO] (Re)starting docker service..."
            sudo systemctl daemon-reload || true
            sudo systemctl enable --now docker || true

            # 빠른 복구 루틴 (stale pid, containerd 이슈 등)
            if ! sudo docker info >/dev/null 2>&1; then
              echo "[WARN] docker not responding; applying quick fixes..."
              sudo rm -f /var/run/docker.pid || true
              sudo systemctl restart containerd || true
              sudo systemctl restart docker
              sleep 3
            fi

            # 최종 확인 (실패 시 로그 덤프 후 종료)
            if ! sudo docker info >/dev/null 2>&1; then
              echo "[ERROR] Docker daemon still down. Showing logs..."
              sudo journalctl -u docker -n 200 --no-pager || true
              sudo journalctl -u containerd -n 200 --no-pager || true
              exit 1
            fi

            # 3) 이미지 pull & 컨테이너 재기동
            echo "[INFO] Pulling image..."
            sudo docker pull "$IMAGE"

            echo "[INFO] Stopping old container (if exists)..."
            sudo docker stop "$CONTAINER_NAME" || true
            sudo docker rm "$CONTAINER_NAME" || true

            echo "[INFO] Running new container..."
            sudo docker run -d --name "$CONTAINER_NAME" \
              -p ${APP_PORT}:${APP_PORT} \
              --restart unless-stopped \
              -e SERVER_PORT=${APP_PORT} \
              "$IMAGE"

            # 4) 용량 정리
            sudo docker image prune -f || true

            # 5) (옵션) 헬스체크: 루트 경로로 간단 확인 (Actuator 없다면 200이 아니어도 무시)
            echo "[INFO] Health check (best-effort)..."
            for i in $(seq 1 15); do
              if curl -fsS "http://127.0.0.1:${APP_PORT}/" >/dev/null 2>&1; then
                echo "[INFO] App responded on port ${APP_PORT}"
                break
              fi
              echo "[INFO] waiting app... ($i/15)"
              sleep 2
            done
